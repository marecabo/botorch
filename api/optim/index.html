<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>BoTorch · Bayesian Optimization in PyTorch</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Bayesian Optimization in PyTorch"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="BoTorch · Bayesian Optimization in PyTorch"/><meta property="og:type" content="website"/><meta property="og:url" content="https://botorch.org/"/><meta property="og:description" content="Bayesian Optimization in PyTorch"/><meta property="og:image" content="https://botorch.org/img/botorch.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://botorch.org/img/botorch.png"/><link rel="shortcut icon" href="/img/botorch.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-139570076-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code_block_buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/code_block_buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/mathjax.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/botorch_logo_lockup_white.png" alt="BoTorch"/><h2 class="headerTitleWithLogo">BoTorch</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/api/" target="_self">API Reference</a></li><li class=""><a href="https://github.com/pytorch/botorch" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div>
<script type="text/javascript" id="documentation_options" data-url_root="./" src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<div class="section" id="module-botorch.optim">
<span id="botorch-optim"></span><h1>botorch.optim<a class="headerlink" href="#module-botorch.optim" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-botorch.optim.fit">
<span id="botorch-optim-fit"></span><h2>botorch.optim.fit<a class="headerlink" href="#module-botorch.optim.fit" title="Permalink to this headline">¶</a></h2>
<p>Tools for model fitting.</p>
<dl class="class">
<dt id="botorch.optim.fit.OptimizationIteration">
<em class="property">class </em><code class="sig-prename descclassname">botorch.optim.fit.</code><code class="sig-name descname">OptimizationIteration</code><span class="sig-paren">(</span><em class="sig-param">itr</em>, <em class="sig-param">fun</em>, <em class="sig-param">time</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/fit.html#OptimizationIteration"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.fit.OptimizationIteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new instance of OptimizationIteration(itr, fun, time)</p>
<dl class="method">
<dt id="botorch.optim.fit.OptimizationIteration.fun">
<em class="property">property </em><code class="sig-name descname">fun</code><a class="headerlink" href="#botorch.optim.fit.OptimizationIteration.fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>
<dl class="method">
<dt id="botorch.optim.fit.OptimizationIteration.itr">
<em class="property">property </em><code class="sig-name descname">itr</code><a class="headerlink" href="#botorch.optim.fit.OptimizationIteration.itr" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>
<dl class="method">
<dt id="botorch.optim.fit.OptimizationIteration.time">
<em class="property">property </em><code class="sig-name descname">time</code><a class="headerlink" href="#botorch.optim.fit.OptimizationIteration.time" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.fit.fit_gpytorch_scipy">
<code class="sig-prename descclassname">botorch.optim.fit.</code><code class="sig-name descname">fit_gpytorch_scipy</code><span class="sig-paren">(</span><em class="sig-param">mll</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">method='L-BFGS-B'</em>, <em class="sig-param">options=None</em>, <em class="sig-param">track_iterations=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/fit.html#fit_gpytorch_scipy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.fit.fit_gpytorch_scipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a gpytorch model by maximizing MLL with a scipy optimizer.</p>
<p>The model and likelihood in mll must already be in train mode.
Note: this method requires that the model has <cite>train_inputs</cite> and <cite>train_targets</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mll</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">MarginalLogLikelihood</span></code>) – MarginalLogLikelihood to be maximized.</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]]) – A dictionary mapping parameter names to tuples of lower and upper
bounds.</p></li>
<li><p><strong>method</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Solver type, passed along to scipy.minimize.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]]) – Dictionary of solver options, passed along to scipy.minimize.</p></li>
<li><p><strong>track_iterations</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Track the function values and wall time for each
iteration.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">MarginalLogLikelihood</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#botorch.optim.fit.OptimizationIteration" title="botorch.optim.fit.OptimizationIteration"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationIteration</span></code></a>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>MarginalLogLikelihood with parameters optimized in-place.</p></li>
<li><p>List of OptimizationIteration objects with information on each
iteration. If track_iterations is False, this will be an empty list.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span> <span class="o">=</span> <span class="n">SingleTaskGP</span><span class="p">(</span><span class="n">train_X</span><span class="p">,</span> <span class="n">train_Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit_gpytorch_scipy</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.fit.fit_gpytorch_torch">
<code class="sig-prename descclassname">botorch.optim.fit.</code><code class="sig-name descname">fit_gpytorch_torch</code><span class="sig-paren">(</span><em class="sig-param">mll</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">optimizer_cls=&lt;class 'torch.optim.adam.Adam'&gt;</em>, <em class="sig-param">options=None</em>, <em class="sig-param">track_iterations=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/fit.html#fit_gpytorch_torch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.fit.fit_gpytorch_torch" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a gpytorch model by maximizing MLL with a torch optimizer.</p>
<p>The model and likelihood in mll must already be in train mode.
Note: this method requires that the model has <cite>train_inputs</cite> and <cite>train_targets</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mll</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">MarginalLogLikelihood</span></code>) – MarginalLogLikelihood to be maximized.</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]]) – A ParameterBounds dictionary mapping parameter names to tuples
of lower and upper bounds. Bounds specified here take precedence
over bounds on the same parameters specified in the constraints
registered with the module.</p></li>
<li><p><strong>optimizer_cls</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Optimizer</span></code>) – Torch optimizer to use. Must not require a closure.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code>]]) – options for model fitting. Relevant options will be passed to
the <cite>optimizer_cls</cite>. Additionally, options can include: “disp”
to specify whether to display model fitting diagnostics and “maxiter”
to specify the maximum number of iterations.</p></li>
<li><p><strong>track_iterations</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Track the function values and wall time for each
iteration.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">MarginalLogLikelihood</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<a class="reference internal" href="#botorch.optim.fit.OptimizationIteration" title="botorch.optim.fit.OptimizationIteration"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimizationIteration</span></code></a>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>mll with parameters optimized in-place.</p></li>
<li><p>List of OptimizationIteration objects with information on each
iteration. If track_iterations is False, this will be an empty list.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gp</span> <span class="o">=</span> <span class="n">SingleTaskGP</span><span class="p">(</span><span class="n">train_X</span><span class="p">,</span> <span class="n">train_Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">gp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fit_gpytorch_torch</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-botorch.optim.initializers">
<span id="botorch-optim-initializers"></span><h2>botorch.optim.initializers<a class="headerlink" href="#module-botorch.optim.initializers" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="botorch.optim.initializers.initialize_q_batch">
<code class="sig-prename descclassname">botorch.optim.initializers.</code><code class="sig-name descname">initialize_q_batch</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em>, <em class="sig-param">n</em>, <em class="sig-param">eta=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/initializers.html#initialize_q_batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.initializers.initialize_q_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Heuristic for selecting initial conditions for candidate generation.</p>
<p>This heuristic selects points from <cite>X</cite> (without replacement) with probability
proportional to <cite>exp(eta * Z)</cite>, where <cite>Z = (Y - mean(Y)) / std(Y)</cite> and <cite>eta</cite>
is a temperature parameter.</p>
<p>When using an acquisiton function that is non-negative and possibly zero
over large areas of the feature space (e.g. qEI), you should use
<cite>initialize_q_batch_nonneg</cite> instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A <cite>b x q x d</cite> tensor of <cite>b</cite> samples of <cite>q</cite>-batches from a <cite>d</cite>-dim.
feature space. Typically, these are generated using qMC sampling.</p></li>
<li><p><strong>Y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A tensor of <cite>b</cite> outcomes associated with the samples. Typically, this
is the value of the batch acquisition function to be maximized.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of initial condition to be generated. Must be less than <cite>b</cite>.</p></li>
<li><p><strong>eta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Temperature parameter for weighting samples.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>n x q x d</cite> tensor of <cite>n</cite> <cite>q</cite>-batch initial conditions.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p># To get <cite>n=10</cite> starting points of q-batch size <cite>q=3</cite> for model with <cite>d=6</cite>:
&gt;&gt;&gt; qUCB = qUpperConfidenceBound(model, beta=0.1)
&gt;&gt;&gt; Xrnd = torch.rand(500, 3, 6)
&gt;&gt;&gt; Xinit = initialize_q_batch(Xrnd, qUCB(Xrnd), 10)</p>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.initializers.initialize_q_batch_nonneg">
<code class="sig-prename descclassname">botorch.optim.initializers.</code><code class="sig-name descname">initialize_q_batch_nonneg</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">Y</em>, <em class="sig-param">n</em>, <em class="sig-param">eta=1.0</em>, <em class="sig-param">alpha=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/initializers.html#initialize_q_batch_nonneg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.initializers.initialize_q_batch_nonneg" title="Permalink to this definition">¶</a></dt>
<dd><p>Heuristic for selecting initial conditions for non-neg. acquisition functions.</p>
<p>This function is similar to <cite>initialize_q_batch</cite>, but designed specifically
for acquisition functions that are non-negative and possibly zero over
large areas of the feature space (e.g. qEI). All samples for which
<cite>Y &lt; alpha * max(Y)</cite> will be ignored (assuming that <cite>Y</cite> contains at least
one positive value).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A <cite>b x q x d</cite> tensor of <cite>b</cite> samples of <cite>q</cite>-batches from a <cite>d</cite>-dim.
feature space. Typically, these are generated using qMC.</p></li>
<li><p><strong>Y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A tensor of <cite>b</cite> outcomes associated with the samples. Typically, this
is the value of the batch acquisition function to be maximized.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of initial condition to be generated. Must be less than <cite>b</cite>.</p></li>
<li><p><strong>eta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Temperature parameter for weighting samples.</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The threshold (as a fraction of the maximum observed value) under
which to ignore samples. All input samples for which
<cite>Y &lt; alpha * max(Y)</cite> will be ignored.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>n x q x d</cite> tensor of <cite>n</cite> <cite>q</cite>-batch initial conditions.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p># To get <cite>n=10</cite> starting points of q-batch size <cite>q=3</cite> for model with <cite>d=6</cite>:
&gt;&gt;&gt; qEI = qExpectedImprovement(model, best_f=0.2)
&gt;&gt;&gt; Xrnd = torch.rand(500, 3, 6)
&gt;&gt;&gt; Xinit = initialize_q_batch(Xrnd, qEI(Xrnd), 10)</p>
</dd></dl>
</div>
<div class="section" id="module-botorch.optim.numpy_converter">
<span id="botorch-optim-numpy-converter"></span><h2>botorch.optim.numpy_converter<a class="headerlink" href="#module-botorch.optim.numpy_converter" title="Permalink to this headline">¶</a></h2>
<p>A converter that simplifies using numpy-based optimizers with generic torch
<cite>nn.Module</cite> classes. This enables using a <cite>scipy.optim.minimize</cite> optimizer
for optimizing module parameters.</p>
<dl class="class">
<dt id="botorch.optim.numpy_converter.TorchAttr">
<em class="property">class </em><code class="sig-prename descclassname">botorch.optim.numpy_converter.</code><code class="sig-name descname">TorchAttr</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">dtype</em>, <em class="sig-param">device</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/numpy_converter.html#TorchAttr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.numpy_converter.TorchAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new instance of TorchAttr(shape, dtype, device)</p>
<dl class="method">
<dt id="botorch.optim.numpy_converter.TorchAttr.device">
<em class="property">property </em><code class="sig-name descname">device</code><a class="headerlink" href="#botorch.optim.numpy_converter.TorchAttr.device" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>
<dl class="method">
<dt id="botorch.optim.numpy_converter.TorchAttr.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#botorch.optim.numpy_converter.TorchAttr.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>
<dl class="method">
<dt id="botorch.optim.numpy_converter.TorchAttr.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#botorch.optim.numpy_converter.TorchAttr.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.numpy_converter.module_to_array">
<code class="sig-prename descclassname">botorch.optim.numpy_converter.</code><code class="sig-name descname">module_to_array</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">exclude=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/numpy_converter.html#module_to_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.numpy_converter.module_to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract named parameters from a module into a numpy array.</p>
<p>Only extracts parameters with requires_grad, since it is meant for optimizing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>) – A module with parameters. May specify parameter constraints in
a <cite>named_parameters_and_constraints</cite> method.</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]]) – A ParameterBounds dictionary mapping parameter names to tuples
of lower and upper bounds. Bounds specified here take precedence
over bounds on the same parameters specified in the constraints
registered with the module.</p></li>
<li><p><strong>exclude</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Set</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – A list of parameter names that are to be excluded from extraction.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tuple</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <a class="reference internal" href="#botorch.optim.numpy_converter.TorchAttr" title="botorch.optim.numpy_converter.TorchAttr"><code class="xref py py-class docutils literal notranslate"><span class="pre">TorchAttr</span></code></a>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3-element tuple containing
- The parameter values as a numpy array.
- An ordered dictionary with the name and tensor attributes of each
parameter.
- A <cite>2 x n_params</cite> numpy array with lower and upper bounds if at least
one constraint is finite, and None otherwise.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_array</span><span class="p">,</span> <span class="n">property_dict</span><span class="p">,</span> <span class="n">bounds_out</span> <span class="o">=</span> <span class="n">module_to_array</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.numpy_converter.set_params_with_array">
<code class="sig-prename descclassname">botorch.optim.numpy_converter.</code><code class="sig-name descname">set_params_with_array</code><span class="sig-paren">(</span><em class="sig-param">module</em>, <em class="sig-param">x</em>, <em class="sig-param">property_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/numpy_converter.html#set_params_with_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.numpy_converter.set_params_with_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Set module parameters with values from numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>) – Module with parameters to be set</p></li>
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Numpy array with parameter values</p></li>
<li><p><strong>property_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <a class="reference internal" href="#botorch.optim.numpy_converter.TorchAttr" title="botorch.optim.numpy_converter.TorchAttr"><code class="xref py py-class docutils literal notranslate"><span class="pre">TorchAttr</span></code></a>]) – Dictionary of parameter names and torch attributes as
returned by module_to_array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>module with parameters updated in-place.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Module</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span> <span class="o">=</span> <span class="n">ExactMarginalLogLikelihood</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_array</span><span class="p">,</span> <span class="n">property_dict</span><span class="p">,</span> <span class="n">bounds_out</span> <span class="o">=</span> <span class="n">module_to_array</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_array</span> <span class="o">+=</span> <span class="mf">0.1</span>  <span class="c1"># perturb parameters (for example only)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mll</span> <span class="o">=</span> <span class="n">set_params_with_array</span><span class="p">(</span><span class="n">mll</span><span class="p">,</span> <span class="n">parameter_array</span><span class="p">,</span>  <span class="n">property_dict</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-botorch.optim.optimize">
<span id="botorch-optim-optimize"></span><h2>botorch.optim.optimize<a class="headerlink" href="#module-botorch.optim.optimize" title="Permalink to this headline">¶</a></h2>
<p>Methods for optimizing acquisition functions.</p>
<dl class="function">
<dt id="botorch.optim.optimize.gen_batch_initial_conditions">
<code class="sig-prename descclassname">botorch.optim.optimize.</code><code class="sig-name descname">gen_batch_initial_conditions</code><span class="sig-paren">(</span><em class="sig-param">acq_function</em>, <em class="sig-param">bounds</em>, <em class="sig-param">q</em>, <em class="sig-param">num_restarts</em>, <em class="sig-param">raw_samples</em>, <em class="sig-param">options=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/optimize.html#gen_batch_initial_conditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.optimize.gen_batch_initial_conditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a batch of initial conditions for random-restart optimziation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>acq_function</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AcquisitionFunction</span></code></a>) – The acquisition function to be optimized.</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A <cite>2 x d</cite> tensor of lower and upper bounds for each column of <cite>X</cite>.</p></li>
<li><p><strong>q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of candidates to consider.</p></li>
<li><p><strong>num_restarts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of starting points for multistart acquisition
function optimization.</p></li>
<li><p><strong>raw_samples</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of raw samples to consider in the initialization
heuristic.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]) – Options for initial condition generation. For valid options see
<cite>initialize_q_batch</cite> and <cite>initialize_q_batch_nonneg</cite>. If <cite>options</cite>
contains a <cite>nonnegative=True</cite> entry, then <cite>acq_function</cite> is
assumed to be non-negative (useful when using custom acquisition
functions).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>num_restarts x q x d</cite> tensor of initial conditions.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qEI</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">best_f</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xinit</span> <span class="o">=</span> <span class="n">gen_batch_initial_conditions</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">qEI</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_restarts</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">=</span><span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.optimize.joint_optimize">
<code class="sig-prename descclassname">botorch.optim.optimize.</code><code class="sig-name descname">joint_optimize</code><span class="sig-paren">(</span><em class="sig-param">acq_function</em>, <em class="sig-param">bounds</em>, <em class="sig-param">q</em>, <em class="sig-param">num_restarts</em>, <em class="sig-param">raw_samples</em>, <em class="sig-param">options=None</em>, <em class="sig-param">inequality_constraints=None</em>, <em class="sig-param">equality_constraints=None</em>, <em class="sig-param">fixed_features=None</em>, <em class="sig-param">post_processing_func=None</em>, <em class="sig-param">batch_initial_conditions=None</em>, <em class="sig-param">return_best_only=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/optimize.html#joint_optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.optimize.joint_optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a set of candidates via joint multi-start optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>acq_function</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AcquisitionFunction</span></code></a>) – The acquisition function.</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A <cite>2 x d</cite> tensor of lower and upper bounds for each column of <cite>X</cite>.</p></li>
<li><p><strong>q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of candidates.</p></li>
<li><p><strong>num_restarts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of starting points for multistart acquisition
function optimization.</p></li>
<li><p><strong>raw_samples</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of samples for initialization.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]) – Options for candidate generation.</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite></p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite></p></li>
<li><p><strong>fixed_features</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – A map {feature_index: value} for features that should be
fixed to a particular value during generation.</p></li>
<li><p><strong>post_processing_func</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]]) – A function that post processes an optimization result
appropriately (i.e., according to <cite>round-trip</cite> transformations).
Note: post_processing_func is not used by _joint_optimize and is only
included to match _sequential_optimize.</p></li>
<li><p><strong>batch_initial_conditions</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]) – A tensor to specify the initial conditions. Set
this if you do not want to use default initialization strategy.</p></li>
<li><p><strong>return_best_only</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Set this to False if you want to output the solutions
corresponding to all initializations.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <cite>q x d</cite> tensor of generated candidates.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># generate `q=2` candidates jointly using 20 random restarts and</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 500 raw samples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qEI</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">best_f</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">candidates</span> <span class="o">=</span> <span class="n">joint_optimize</span><span class="p">(</span><span class="n">qEI</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.optimize.sequential_optimize">
<code class="sig-prename descclassname">botorch.optim.optimize.</code><code class="sig-name descname">sequential_optimize</code><span class="sig-paren">(</span><em class="sig-param">acq_function</em>, <em class="sig-param">bounds</em>, <em class="sig-param">q</em>, <em class="sig-param">num_restarts</em>, <em class="sig-param">raw_samples</em>, <em class="sig-param">options=None</em>, <em class="sig-param">inequality_constraints=None</em>, <em class="sig-param">equality_constraints=None</em>, <em class="sig-param">fixed_features=None</em>, <em class="sig-param">post_processing_func=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/optimize.html#sequential_optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.optimize.sequential_optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a set of candidates via sequential multi-start optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>acq_function</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">AcquisitionFunction</span></code></a>) – An AcquisitionFunction</p></li>
<li><p><strong>bounds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – A <cite>2 x d</cite> tensor of lower and upper bounds for each column of <cite>X</cite>.</p></li>
<li><p><strong>q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of candidates.</p></li>
<li><p><strong>num_restarts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of starting points for multistart acquisition
function optimization.</p></li>
<li><p><strong>raw_samples</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of samples for initialization</p></li>
<li><p><strong>options</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]) – Options for candidate generation.</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite></p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite></p></li>
<li><p><strong>fixed_features</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]) – A map <cite>{feature_index: value}</cite> for features that
should be fixed to a particular value during generation.</p></li>
<li><p><strong>post_processing_func</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]]) – A function that post-processes an optimization
result appropriately (i.e., according to <cite>round-trip</cite>
transformations).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The set of generated candidates.</p>
</dd>
</dl>
<dl class="simple">
<dt>Example</dt><dd><p># generate <cite>q=2</cite> candidates sequentially using 20 random restarts
# and 500 raw samples
&gt;&gt;&gt; qEI = qExpectedImprovement(model, best_f=0.2)
&gt;&gt;&gt; bounds = torch.tensor([[0.], [1.]])
&gt;&gt;&gt; candidates = sequential_optimize(qEI, bounds, 2, 20, 500)</p>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="module-botorch.optim.parameter_constraints">
<span id="botorch-optim-parameter-constraints"></span><h2>botorch.optim.parameter_constraints<a class="headerlink" href="#module-botorch.optim.parameter_constraints" title="Permalink to this headline">¶</a></h2>
<p>Utility functions for constrained optimization.</p>
<dl class="function">
<dt id="botorch.optim.parameter_constraints.eval_lin_constraint">
<code class="sig-prename descclassname">botorch.optim.parameter_constraints.</code><code class="sig-name descname">eval_lin_constraint</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">flat_idxr</em>, <em class="sig-param">coeffs</em>, <em class="sig-param">rhs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/parameter_constraints.html#eval_lin_constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.parameter_constraints.eval_lin_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a single linear constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input array.</p></li>
<li><p><strong>flat_idxr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The indices in <cite>x</cite> to consider.</p></li>
<li><p><strong>coeffs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The coefficients corresponding to the indices.</p></li>
<li><p><strong>rhs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The right-hand-side of the constraint.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>sum_i (coeffs[i] * x[i]) - rhs</cite></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The evaluted constraint</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.parameter_constraints.lin_constraint_jac">
<code class="sig-prename descclassname">botorch.optim.parameter_constraints.</code><code class="sig-name descname">lin_constraint_jac</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">flat_idxr</em>, <em class="sig-param">coeffs</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/parameter_constraints.html#lin_constraint_jac"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.parameter_constraints.lin_constraint_jac" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Jacobian associated with a linear constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input array.</p></li>
<li><p><strong>flat_idxr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – The indices for the elements of x that appear in the constraint.</p></li>
<li><p><strong>coeffs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The coefficients corresponding to the indices.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – number of elements</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The Jacobian.</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.parameter_constraints.make_scipy_bounds">
<code class="sig-prename descclassname">botorch.optim.parameter_constraints.</code><code class="sig-name descname">make_scipy_bounds</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">lower_bounds=None</em>, <em class="sig-param">upper_bounds=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/parameter_constraints.html#make_scipy_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.parameter_constraints.make_scipy_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a scipy Bounds object for optimziation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – <cite>… x d</cite> tensor</p></li>
<li><p><strong>lower_bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>]) – Lower bounds on each column (last dimension) of <cite>X</cite>. If
this is a single float, then all columns have the same bound.</p></li>
<li><p><strong>upper_bounds</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>]) – Lower bounds on each column (last dimension) of <cite>X</cite>. If
this is a single float, then all columns have the same bound.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Bounds</span></code>]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A scipy <cite>Bounds</cite> object if either lower_bounds or upper_bounds is not
None, and None otherwise.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scipy_bounds</span> <span class="o">=</span> <span class="n">make_scipy_bounds</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.parameter_constraints.make_scipy_linear_constraints">
<code class="sig-prename descclassname">botorch.optim.parameter_constraints.</code><code class="sig-name descname">make_scipy_linear_constraints</code><span class="sig-paren">(</span><em class="sig-param">shapeX</em>, <em class="sig-param">inequality_constraints=None</em>, <em class="sig-param">equality_constraints=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/parameter_constraints.html#make_scipy_linear_constraints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.parameter_constraints.make_scipy_linear_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate scipy constraints from torch representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shapeX</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Size</span></code>) – The shape of the torch.Tensor to optimize over (i.e. <cite>b x q x d</cite>)</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>, where
<cite>indices</cite> is a single-dimensional index tensor (long dtype) containing
indices into the last dimension of <cite>X</cite>, <cite>coefficients</cite> is a
single-dimensional tensor of coefficients of the same length, and
rhs is a scalar.</p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) == rhs</cite> (with <cite>indices</cite>
and <cite>coefficients</cite> of the same form as in <cite>inequality_constraints</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>], <code class="xref py py-data docutils literal notranslate"><span class="pre">Callable</span></code>[[<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>], <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>]]]]</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of dictionaries containing callables for constraint function
values and Jacobians and a string indicating the associated constraint
type (“eq”, “ineq”), as expected by <cite>scipy.minimize</cite>.</p>
</dd>
</dl>
<p>This function assumes that constraints are the same for each input batch,
and broadcasts the constraints accordingly to the input batch shape. This
function does support constraints across elements of a q-batch if the
indices are a 2-d Tensor.</p>
<p class="rubric">Example</p>
<p>The following will enforce that <cite>x[1] + 0.5 x[3] &gt;= -0.1</cite> for each <cite>x</cite>
in both elements of the q-batch, and each of the 3 t-batches:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constraints</span> <span class="o">=</span> <span class="n">make_scipy_linear_constraints</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">[(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)],</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<p>The following will enforce that <cite>x[0, 1] + 0.5 x[1, 3] &gt;= -0.1</cite> where
x[0, :] is the first element of the q-batch and x[1, :] is the second
element of the q-batch, for each of the 3 t-batches:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constraints</span> <span class="o">=</span> <span class="n">make_scipy_linear_constraints</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">torch</span><span class="o">.</span><span class="n">size</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">[(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">)],</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="module-botorch.optim.utils">
<span id="botorch-optim-utils"></span><h2>botorch.optim.utils<a class="headerlink" href="#module-botorch.optim.utils" title="Permalink to this headline">¶</a></h2>
<p>Utilities for optimization.</p>
<dl class="function">
<dt id="botorch.optim.utils.check_convergence">
<code class="sig-prename descclassname">botorch.optim.utils.</code><code class="sig-name descname">check_convergence</code><span class="sig-paren">(</span><em class="sig-param">loss_trajectory</em>, <em class="sig-param">param_trajectory</em>, <em class="sig-param">options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/utils.html#check_convergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.utils.check_convergence" title="Permalink to this definition">¶</a></dt>
<dd><p>Check convergence of optimization for pytorch optimizers.</p>
<p>Right now this is just a dummy function and only checks for maxiter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loss_trajectory</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]) – A list containing the loss value at each iteration.</p></li>
<li><p><strong>param_trajectory</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>]]) – A dictionary mapping each parameter name to a list of Tensors
where the <cite>i`th Tensor is the parameter value at iteration `i</cite>.</p></li>
<li><p><strong>options</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]]) – dictionary of options. Currently only “maxiter” is supported.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A boolean indicating whether optimization has converged.</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.utils.columnwise_clamp">
<code class="sig-prename descclassname">botorch.optim.utils.</code><code class="sig-name descname">columnwise_clamp</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">raise_on_violation=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/utils.html#columnwise_clamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.utils.columnwise_clamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Clamp values of a Tensor in column-wise fashion (with support for t-batches).</p>
<p>This function is useful in conjunction with optimizers from the torch.optim
package, which don’t natively handle constraints. If you apply this after
a gradient step you can be fancy and call it “projected gradient descent”.
This funtion is also useful for post-processing candidates generated by the
scipy optimizer that satisfy bounds only up to numerical accuracy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – The <cite>b x n x d</cite> input tensor. If 2-dimensional, <cite>b</cite> is assumed to be 1.</p></li>
<li><p><strong>lower</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>]) – The column-wise lower bounds. If scalar, apply bound to all columns.</p></li>
<li><p><strong>upper</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>]) – The column-wise upper bounds. If scalar, apply bound to all columns.</p></li>
<li><p><strong>raise_on_violation</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If <cite>True</cite>, raise an exception when the elments in <cite>X</cite>
are out of the specified bounds (up to numerical accuracy). This is
useful for post-processing candidates generated by optimizers that
satisfy imposed bounds only up to numerical accuracy.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The clamped tensor.</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.utils.fix_features">
<code class="sig-prename descclassname">botorch.optim.utils.</code><code class="sig-name descname">fix_features</code><span class="sig-paren">(</span><em class="sig-param">X</em>, <em class="sig-param">fixed_features=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/utils.html#fix_features"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.utils.fix_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix feature values in a Tensor.</p>
<p>The fixed features will have zero gradient in downstream calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) – input Tensor with shape <cite>… x p</cite>, where <cite>p</cite> is the number of features</p></li>
<li><p><strong>fixed_features</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>]]]) – A dictionary with keys as column indices and values
equal to what the feature should be set to in <cite>X</cite>. If the value is
None, that column is just considered fixed. Keys should be in the
range <cite>[0, p - 1]</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The tensor X with fixed features.</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="botorch.optim.utils.sample_all_priors">
<code class="sig-prename descclassname">botorch.optim.utils.</code><code class="sig-name descname">sample_all_priors</code><span class="sig-paren">(</span><em class="sig-param">model</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/optim/utils.html#sample_all_priors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#botorch.optim.utils.sample_all_priors" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from hyperparameter priors (in-place).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.gpytorch.GPyTorchModel" title="botorch.models.gpytorch.GPyTorchModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GPyTorchModel</span></code></a>) – A GPyTorchModel.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">BoTorch</a></h1>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="gen.html">botorch.gen</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">botorch.utils</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="posteriors.html" title="previous chapter">botorch.posteriors</a></li>
<li>Next: <a href="fit.html" title="next chapter">botorch.fit</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" name="q" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/botorch.png" alt="BoTorch" width="66" height="58"/></a><div class="footerSection"><h5>Docs</h5><a href="/docs/introduction">Introduction</a><a href="/docs/getting_started">Getting Started</a><a href="/tutorials">Tutorials</a><a href="/api">API Reference</a></div><div class="footerSection"><h5>Social</h5><div class="social"><a class="github-button" href="https://github.com/pytorch/botorch" data-count-href="https://github.com/pytorch/botorch/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star BoTorch on GitHub">botorch</a></div></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright"> Copyright © 2019 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '207c27d819f967749142d8611de7cb19',
                indexName: 'botorch',
                inputSelector: '#search_input_react'
              });
            </script></body></html>